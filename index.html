<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BitNexys - Crypto Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/date-fns@2.29.3/index.min.js"></script>
    <style>
        :root {
            --background-primary: #0a0b0d;
            --background-secondary: #161821;
            --background-tertiary: #1e2029;
            --background-card: #242731;
            --text-primary: #e8e9ea;
            --text-secondary: #b8bcc8;
            --text-muted: #9ca3af;
            --accent-color: #f7931a;
            --accent-secondary: #ff6b35;
            --positive-change: #10b981;
            --negative-change: #ef4444;
            --border-color: #374151;
            --border-light: #4b5563;
            --font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --card-shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
            --card-hover-shadow: 0 8px 30px rgba(0, 0, 0, 0.35);
            --border-radius: 12px;
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-family);
            background: linear-gradient(135deg, var(--background-primary) 0%, var(--background-secondary) 100%);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        a {
            color: var(--accent-color);
            text-decoration: none;
            transition: var(--transition);
        }

        a:hover {
            color: var(--accent-secondary);
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 30px 0 40px;
            border-bottom: 2px solid var(--border-color);
            margin-bottom: 30px;
            position: relative;
        }

        header::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 60px;
            height: 2px;
            background: linear-gradient(90deg, var(--accent-color), var(--accent-secondary));
        }

        header h1 {
            color: var(--accent-color);
            font-size: 2.5em;
            font-weight: 700;
            letter-spacing: -0.5px;
            background: linear-gradient(135deg, var(--accent-color), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        header h1 .vylex {
            color: var(--text-primary);
            -webkit-text-fill-color: var(--text-primary);
        }

        .header-stats {
            display: flex;
            gap: 20px;
            align-items: center;
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        .stat-value {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 1.1em;
        }

        .card {
            background: linear-gradient(145deg, var(--background-card), var(--background-tertiary));
            border-radius: var(--border-radius);
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: var(--card-shadow);
            border: 1px solid var(--border-color);
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--accent-color), var(--accent-secondary));
            opacity: 0.7;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: var(--card-hover-shadow);
            border-color: var(--border-light);
        }

        .card h2,
        .card h3 {
            color: var(--text-primary);
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card h2::before {
            content: '';
            width: 4px;
            height: 20px;
            background: linear-gradient(135deg, var(--accent-color), var(--accent-secondary));
            border-radius: 2px;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 25px;
        }

        .full-width-card {
            grid-column: 1 / -1;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid var(--background-tertiary);
            transition: var(--transition);
        }

        .metric-row:hover {
            background: rgba(255, 255, 255, 0.02);
            margin: 0 -10px;
            padding-left: 10px;
            padding-right: 10px;
            border-radius: 6px;
        }

        .metric-row:last-child {
            border-bottom: none;
        }

        .metric-label {
            color: var(--text-secondary);
            font-weight: 500;
        }

        .metric-value,
        .value {
            font-weight: 600;
            color: var(--text-primary);
        }

        #btcPrice {
            font-size: 3em;
            background: linear-gradient(135deg, var(--accent-color), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 700;
            letter-spacing: -1px;
        }

        .price-change {
            font-size: 1.3em;
            margin-left: 15px;
            font-weight: 600;
            padding: 5px 12px;
            border-radius: 8px;
        }

        .positive {
            color: var(--positive-change);
            background: rgba(16, 185, 129, 0.1);
        }

        .negative {
            color: var(--negative-change);
            background: rgba(239, 68, 68, 0.1);
        }

        select,
        input[type="number"],
        input[type="text"],
        button {
            padding: 12px 16px;
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color);
            background: var(--background-tertiary);
            color: var(--text-primary);
            font-size: 0.95em;
            font-family: var(--font-family);
            margin: 5px 0;
            transition: var(--transition);
        }

        select:focus,
        input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(247, 147, 26, 0.1);
        }

        button {
            cursor: pointer;
            background: linear-gradient(135deg, var(--accent-color), var(--accent-secondary));
            color: white;
            border: none;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.85em;
            letter-spacing: 0.5px;
        }

        button:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(247, 147, 26, 0.3);
        }

        button:disabled {
            background: var(--text-muted);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        button.active {
            background: linear-gradient(135deg, var(--accent-secondary), var(--accent-color));
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.3);
        }

        .timeframe-btn {
            margin-right: 8px;
            margin-bottom: 8px;
            min-width: 50px;
        }

        #priceChartContainer {
            height: 450px;
            position: relative;
            margin-top: 20px;
        }

        #fearGreedGauge {
            width: 100%;
            max-width: 280px;
            height: auto;
            display: block;
            margin: 0 auto 15px;
        }

        #fearGreedInfo {
            text-align: center;
        }

        #fearGreedValue {
            font-size: 2.5em;
            font-weight: 700;
            margin-bottom: 5px;
        }

        #fearGreedLabel {
            font-size: 1.3em;
            margin-bottom: 8px;
            font-weight: 600;
        }

        #fearGreedUpdate {
            font-size: 0.85em;
            color: var(--text-muted);
        }

        #supplyProgressContainer {
            width: 100%;
            background: var(--background-tertiary);
            border-radius: 10px;
            overflow: hidden;
            height: 12px;
            margin-top: 10px;
            position: relative;
        }

        #supplyProgress {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-color), var(--accent-secondary));
            width: 0%;
            transition: width 1s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 10px;
        }

        .supply-percentage {
            position: absolute;
            top: -25px;
            right: 0;
            font-size: 0.8em;
            color: var(--text-secondary);
            font-weight: 600;
        }

        .news-item {
            border: 1px solid var(--border-color);
            padding: 20px;
            margin-bottom: 20px;
            border-radius: var(--border-radius);
            background: linear-gradient(145deg, var(--background-tertiary), var(--background-card));
            transition: var(--transition);
        }

        .news-item:hover {
            transform: translateY(-2px);
            border-color: var(--border-light);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }

        .news-item h3 a {
            color: var(--text-primary);
            font-weight: 600;
            line-height: 1.4;
            transition: var(--transition);
        }

        .news-item h3 a:hover {
            color: var(--accent-color);
        }

        .news-item p {
            margin: 8px 0;
            font-size: 0.95em;
            line-height: 1.5;
        }

        .news-item .meta-info {
            color: var(--text-muted);
            font-size: 0.85em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .news-item img {
            max-width: 120px;
            float: right;
            margin-left: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        #news-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 20px;
        }

        #news-controls button {
            font-size: 0.8em;
            padding: 8px 16px;
        }

        .loading-text,
        .loading {
            text-align: center;
            padding: 30px;
            color: var(--text-muted);
            font-style: italic;
        }

        .error,
        .widget-error-message {
            color: var(--negative-change);
            background: rgba(239, 68, 68, 0.1);
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 15px;
            border: 1px solid var(--negative-change);
            border-left: 4px solid var(--negative-change);
        }

        #error-container {
            margin-top: 15px;
        }

        .coin-logo {
            width: 24px;
            height: 24px;
            margin-right: 10px;
            vertical-align: middle;
            border-radius: 50%;
        }

        .data-source-notice {
            font-size: 0.8em;
            color: var(--text-muted);
            text-align: right;
            margin-top: 15px;
            font-style: italic;
        }

        .pulse-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            background: var(--positive-change);
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Status indicators */
        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            font-size: 0.8em;
            padding: 4px 8px;
            border-radius: 12px;
            background: rgba(16, 185, 129, 0.1);
            color: var(--positive-change);
        }

        /* Footer */
        footer {
            text-align: center;
            padding: 40px 20px;
            margin-top: 50px;
            border-top: 1px solid var(--border-color);
            font-size: 0.9em;
            color: var(--text-muted);
            background: var(--background-secondary);
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            .grid-container {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            header {
                flex-direction: column;
                align-items: flex-start;
                gap: 20px;
            }

            header h1 {
                font-size: 2em;
                margin-bottom: 10px;
            }

            .header-stats {
                width: 100%;
                justify-content: space-around;
            }

            #btcPrice {
                font-size: 2.2em;
            }

            .news-item img {
                float: none;
                display: block;
                margin: 0 auto 15px;
                max-width: 200px;
            }

            .card {
                padding: 20px;
            }

            #priceChartContainer {
                height: 350px;
            }
        }

        @media (max-width: 480px) {
            .header-stats {
                flex-direction: column;
                gap: 10px;
            }

            .timeframe-btn {
                font-size: 0.75em;
                padding: 6px 10px;
                min-width: 40px;
            }

            #news-controls {
                justify-content: center;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <div>
                <h1>Bit<span class="vylex">Nexys</span></h1>
                <div class="status-indicator">
                    <span class="pulse-indicator"></span>
                    Live Data
                </div>
            </div>
            <div class="header-stats">
                <div class="stat-item">
                    <div class="stat-value" id="headerDominance">--</div>
                    <div>BTC Dominance</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="headerFearGreed">--</div>
                    <div>Fear & Greed</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="headerBlocks">--</div>
                    <div>Block Height</div>
                </div>
            </div>
        </header>

        <div id="error-container"></div>

        <div class="grid-container">
            <!-- Bitcoin Price Widget -->
            <div class="card" id="bitcoin-price-widget">
                <h2>Bitcoin (BTC) Price
                    <select id="currencySelect">
                        <option value="usd">USD</option>
                        <option value="eur">EUR</option>
                        <option value="jpy">JPY</option>
                        <option value="gbp">GBP</option>
                        <option value="zar">ZAR</option>
                    </select>
                </h2>
                <div style="margin-bottom: 20px;">
                    <span id="btcPrice">Loading...</span>
                    <span id="priceChange" class="price-change">--%</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Market Cap:</span>
                    <span id="marketCap" class="metric-value">Loading...</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">24h Volume:</span>
                    <span id="volume24h" class="metric-value">Loading...</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">24h High:</span>
                    <span id="high24h" class="metric-value">Loading...</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">24h Low:</span>
                    <span id="low24h" class="metric-value">Loading...</span>
                </div>
                <p class="data-source-notice">Data: CoinGecko</p>
            </div>

            <!-- Market Data / Supply Widget -->
            <div class="card" id="market-data-widget">
                <h2>Market Data</h2>
                <div class="metric-row">
                    <span class="metric-label">BTC Dominance:</span>
                    <span id="dominance" class="metric-value">Loading...</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Circulating Supply:</span>
                    <span id="circulating" class="metric-value">Loading...</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Total Supply (Max):</span>
                    <span id="totalSupply" class="metric-value">21,000,000 BTC</span>
                </div>
                <div id="supplyProgressContainer">
                    <div class="supply-percentage" id="supplyPercentage">0%</div>
                    <div id="supplyProgress"></div>
                </div>
                <p class="data-source-notice">Data: CoinGecko</p>
            </div>

            <!-- Fear & Greed Index -->
            <div class="card" id="fear-greed-widget">
                <h2>Fear & Greed Index</h2>
                <canvas id="fearGreedGauge" width="280" height="150"></canvas>
                <div id="fearGreedInfo">
                    <div id="fearGreedValue">--</div>
                    <div id="fearGreedLabel">Loading...</div>
                    <div id="fearGreedUpdate">Loading...</div>
                </div>
                <p class="data-source-notice">Data: alternative.me</p>
            </div>

            <!-- Price Chart -->
            <div class="card full-width-card" id="price-chart-widget">
                <h2>Bitcoin Price Chart</h2>
                <div>
                    <button class="timeframe-btn active" data-days="1">1D</button>
                    <button class="timeframe-btn" data-days="7">7D</button>
                    <button class="timeframe-btn" data-days="30">1M</button>
                    <button class="timeframe-btn" data-days="90">3M</button>
                    <button class="timeframe-btn" data-days="365">1Y</button>
                    <button class="timeframe-btn" data-days="max">Max</button>
                </div>
                <div id="priceChartContainer">
                    <canvas id="priceChart"></canvas>
                </div>
                <p class="data-source-notice">Data: CoinGecko</p>
            </div>

            <!-- Network Stats -->
            <div class="card" id="network-stats-widget">
                <h2>Network Stats</h2>
                <div class="metric-row">
                    <span class="metric-label">Hash Rate (7d Avg):</span>
                    <span id="hashRate" class="metric-value">Loading...</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Difficulty:</span>
                    <span id="difficulty" class="metric-value">Loading...</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Next Difficulty Adj:</span>
                    <span id="nextDifficulty" class="metric-value">Loading...</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Current Block Height:</span>
                    <span id="blockHeight" class="metric-value">Loading...</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Halving Countdown:</span>
                    <span id="halvingCountdown" class="metric-value">Loading...</span>
                </div>
                <p class="data-source-notice">Data: mempool.space</p>
            </div>

            <!-- Mempool Data -->
            <div class="card" id="mempool-data-widget">
                <h2>Mempool & Fees</h2>
                <div class="metric-row">
                    <span class="metric-label">High Priority Fee:</span>
                    <span id="highPriorityFee" class="metric-value">Loading...</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Medium Priority Fee:</span>
                    <span id="mediumPriorityFee" class="metric-value">Loading...</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Low Priority Fee:</span>
                    <span id="lowPriorityFee" class="metric-value">Loading...</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Mempool Size:</span>
                    <span id="mempoolSize" class="metric-value">Loading...</span>
                </div>
                <p class="data-source-notice">Data: mempool.space</p>
            </div>

            <!-- Recent Blocks -->
            <div class="card" id="recent-blocks-widget">
                <h2>Recent Blocks</h2>
                <div id="recentBlocks">
                    <p class="loading-text">Loading recent blocks...</p>
                </div>
                <p class="data-source-notice">Data: mempool.space</p>
            </div>

            <!-- Currency Converter -->
            <div class="card">
                <h2>Currency Converter</h2>
                <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                    <input type="number" id="amount" value="1" style="flex: 1; min-width: 100px;">
                    <select id="fromCurrency" style="flex: 1; min-width: 80px;"></select>
                    <span style="color: var(--text-secondary);">to</span>
                    <select id="toCurrency" style="flex: 1; min-width: 80px;"></select>
                    <button onclick="convert()" style="flex: 0;">Convert</button>
                </div>
                <p id="result" style="margin-top: 15px; font-weight: bold; padding: 10px; background: var(--background-tertiary); border-radius: 8px;">Enter an amount to convert.</p>
                <p class="data-source-notice">Rates: CoinGecko / Frankfurter.app</p>
            </div>

            <!-- Market Overview (Other Coins) -->
            <div class="card" id="market-overview-widget">
                <h2>Market Overview</h2>
                <div id="market-overview-content">
                    <p class="loading-text">Loading market data...</p>
                </div>
                <p class="data-source-notice">Data: CoinGecko</p>
            </div>

            <!-- Crypto Terminology -->
            <div class="card">
                <h2>Crypto Term of the Moment</h2>
                <h3 id="term-title" style="color: var(--accent-color);">Loading...</h3>
                <p id="term-definition" style="line-height: 1.6; margin-top: 10px;">Loading definition...</p>
                <button id="new-term-button" style="margin-top: 15px;">New Term</button>
            </div>

            <!-- Crypto Quote -->
            <div class="card">
                <h2>Crypto Wisdom</h2>
                <p id="quote-text" style="font-style: italic; font-size: 1.1em; line-height: 1.5; color: var(--text-secondary);">Loading quote...</p>
                <button id="quote-button" style="margin-top: 15px;">💬 Get Quote</button>
            </div>

            <!-- News Section -->
            <div class="card full-width-card" id="news-feed-widget">
                <h2>Crypto News Feed</h2>
                <div id="news-controls">
                    <button class="category-btn active" data-source="all_crypto">All Crypto</button>
                    <button class="category-btn" data-source="bitcoin">Bitcoin</button>
                    <button class="category-btn" data-source="ethereum">Ethereum</button>
                    <button class="category-btn" data-source="altcoins">Altcoins</button>
                    <button class="category-btn" data-source="defi">DeFi</button>
                    <button class="category-btn" data-source="nfts">NFTs</button>
                </div>
                <div id="loading" style="display: none;">Loading news...</div>
                <div id="news-container" style="margin-top: 15px;">
                    <!-- News items will be injected here -->
                </div>
                <p class="data-source-notice">Data: Reddit</p>
            </div>
        </div>

        <footer>
            <p><span id="copyright-year"></span></p>
            <p>Disclaimer: This tool is for informational purposes only. Not financial advice.</p>
        </footer>
    </div>

    <script>
        // --- APP CONFIG & STATE ---
        const appConfig = {
            coinGeckoApiUrl: 'https://api.coingecko.com/api/v3',
            fearGreedApiUrl: 'https://api.alternative.me/fng/?limit=1',
            mempoolSpaceApiUrl: 'https://mempool.space/api',
            defaultCurrency: 'usd',
            storageKeys: {
                selectedCurrency: 'bitnexys_currency',
            },
            cryptoQuotes: [
                "HODL: Hold On for Dear Life.", "To the moon! 🚀", "Not your keys, not your coins.", "DYOR: Do Your Own Research.", "Buy the dip!", "WAGMI: We're All Gonna Make It.", "Decentralization is not a destination, it's a journey.", "The blockchain is a solution in search of a problem... and finding many.", "If you don't believe it or don't get it, I don't have the time to try to convince you, sorry. - Satoshi Nakamoto (paraphrased)", "Stay humble, stack sats.", "Bitcoin is digital gold.", "The future of money is decentralized.", "Be your own bank.", "In code we trust.", "Sats are the new cents.", "Scarcity creates value -- only 21 million BTC.", "Crypto never sleeps.", "Volatility is the price of opportunity.", "Bear markets build strong hands.", "Stack sats like your future depends on it -- because it does."
            ],
            cryptoTerms: [
                { term: "Blockchain", definition: "A distributed, immutable ledger that records transactions and tracks assets across a network." },
                { term: "Cryptocurrency", definition: "A digital or virtual currency secured by cryptography, making it nearly impossible to counterfeit." },
                { term: "Bitcoin (BTC)", definition: "The first decentralized cryptocurrency, created in 2009 by Satoshi Nakamoto." },
                { term: "Ethereum (ETH)", definition: "A decentralized, open-source blockchain with smart contract functionality." },
                { term: "Smart Contract", definition: "Self-executing contracts with the terms of the agreement directly written into code." },
                { term: "DeFi (Decentralized Finance)", definition: "Financial services built on blockchain technology, without relying on central intermediaries." },
                { term: "NFT (Non-Fungible Token)", definition: "A unique digital asset representing ownership of items like art, collectibles, or virtual land." },
                { term: "HODL", definition: "A popular crypto slang term meaning 'Hold On for Dear Life', encouraging long-term holding." },
                { term: "Mining", definition: "The process of verifying and adding transactions to a blockchain, often rewarded with new cryptocurrency." },
                { term: "Wallet (Crypto)", definition: "A digital wallet used to store, send, and receive cryptocurrencies, holding private and public keys." },
                { term: "Altcoin", definition: "Any cryptocurrency other than Bitcoin." },
                { term: "Market Cap", definition: "The total market value of a cryptocurrency's circulating supply. (Current Price x Circulating Supply)" },
                { term: "Gas Fees", definition: "Transaction fees on the Ethereum network, paid to miners/validators for processing transactions." },
                { term: "Whitepaper", definition: "An authoritative report or guide that informs readers concisely about a complex issue, often used to launch new crypto projects." },
                { term: "Whale", definition: "An individual or entity that holds a large amount of a specific cryptocurrency." }
            ]
        };

        const redditSources = {
            all_crypto: 'https://www.reddit.com/r/CryptoCurrency/.json?limit=20&sort=hot',
            bitcoin: 'https://www.reddit.com/r/Bitcoin/.json?limit=20&sort=hot',
            ethereum: 'https://www.reddit.com/r/ethereum/.json?limit=20&sort=hot',
            altcoins: 'https://www.reddit.com/r/altcoin/.json?limit=20&sort=hot',
            defi: 'https://www.reddit.com/r/defi/.json?limit=20&sort=hot',
            nfts: 'https://www.reddit.com/r/NFT/.json?limit=20&sort=hot'
        };

        let currentNewsCategory = 'all_crypto';
        let cachedNews = {};
        let bitnexysApp;

        // --- HELPER & ERROR FUNCTIONS ---
        function showError(message, contextId = null, isCritical = false) {
            clearError(contextId);
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.innerHTML = `<strong>Error:</strong> ${message}`;

            if (contextId) {
                const widgetContainer = document.getElementById(contextId);
                if (widgetContainer) {
                    let widgetErrorDisplay = widgetContainer.querySelector('.widget-error-message');
                    if (!widgetErrorDisplay) {
                        widgetErrorDisplay = document.createElement('p');
                        widgetErrorDisplay.className = 'widget-error-message';
                        const dataSourceNotice = widgetContainer.querySelector('.data-source-notice');
                        if (dataSourceNotice) {
                            widgetContainer.insertBefore(widgetErrorDisplay, dataSourceNotice);
                        } else {
                            const firstContentElement = Array.from(widgetContainer.children).find(child => child.tagName !== 'H2');
                            if (firstContentElement) {
                                widgetContainer.insertBefore(widgetErrorDisplay, firstContentElement);
                            } else {
                                widgetContainer.appendChild(widgetErrorDisplay);
                            }
                        }
                    }
                    widgetErrorDisplay.textContent = `Error: ${message.substring(0, 150)}${message.length > 150 ? '...' : ''}`;
                } else if (isCritical) {
                    document.getElementById('error-container').appendChild(errorDiv);
                }
            } else {
                document.getElementById('error-container').appendChild(errorDiv);
            }
            console.error(`Error Displayed (Context: ${contextId || 'General'}):`, message);
        }

        function clearError(contextId = null) {
            if (contextId) {
                const widgetContainer = document.getElementById(contextId);
                if (widgetContainer) {
                    const widgetError = widgetContainer.querySelector('.widget-error-message');
                    if (widgetError) widgetError.remove();
                }
            } else {
                const generalErrorContainer = document.getElementById('error-container');
                const generalErrors = generalErrorContainer.querySelectorAll('.error');
                generalErrors.forEach(err => err.remove());
            }
        }

        // --- BitNexys CLASS ---
        class BitNexys {
            constructor(initialCurrency = 'usd') {
                this.currency = initialCurrency;
                this.currentTimeframe = '1';
                this.priceChart = null;
                this.currentBlockHeight = null;
                setTimeout(() => this.init(), 0);
            }

            async init() {
                this.setupEventListeners();
                await this.loadAllData();
                this.setupPeriodicUpdates();
            }

            setupEventListeners() {
                document.getElementById('currencySelect').addEventListener('change', async (e) => {
                    this.currency = e.target.value;
                    localStorage.setItem(appConfig.storageKeys.selectedCurrency, this.currency);
                    clearError('bitcoin-price-widget');
                    clearError('price-chart-widget');
                    clearError('market-data-widget');

                    await this.loadPriceData();
                    this.loadPriceChart();
                    fetchMarketOverviewData(this.currency);
                });

                document.querySelectorAll('.timeframe-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.timeframe-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.currentTimeframe = e.target.dataset.days;
                        clearError('price-chart-widget');
                        this.loadPriceChart();
                    });
                });
            }

            async loadAllData() {
                await Promise.allSettled([
                    this.loadPriceData(),
                    this.loadFearGreedIndex(),
                    this.loadNetworkStats(),
                    this.loadMempoolData(),
                    this.loadPriceChart(),
                    this.loadRecentBlocks(),
                ]);
            }

            async loadPriceData() {
                const widgetId = 'bitcoin-price-widget';
                try {
                    const response = await fetch(`${appConfig.coinGeckoApiUrl}/simple/price?ids=bitcoin&vs_currencies=${this.currency}&include_market_cap=true&include_24hr_vol=true&include_24hr_change=true`);
                    if (!response.ok) throw new Error(`CoinGecko API error (${response.status}) for price`);
                    const data = await response.json();

                    if (!data.bitcoin || !data.bitcoin[this.currency.toLowerCase()]) {
                        throw new Error(`Bitcoin data not found for currency: ${this.currency.toUpperCase()}`);
                    }
                    const btcInfo = data.bitcoin;
                    const price = btcInfo[this.currency.toLowerCase()];
                    const change = btcInfo[`${this.currency.toLowerCase()}_24h_change`];
                    const marketCap = btcInfo[`${this.currency.toLowerCase()}_market_cap`];
                    const volume = btcInfo[`${this.currency.toLowerCase()}_24h_vol`];

                    document.getElementById('btcPrice').textContent = this.formatCurrency(price, this.currency);

                    const changeEl = document.getElementById('priceChange');
                    changeEl.textContent = `${change >= 0 ? '+' : ''}${change.toFixed(2)}%`;
                    changeEl.className = `price-change ${change >= 0 ? 'positive' : 'negative'}`;

                    document.getElementById('marketCap').textContent = this.formatLargeNumber(marketCap, this.currency);
                    document.getElementById('volume24h').textContent = this.formatLargeNumber(volume, this.currency);

                    clearError(widgetId);
                    await this.loadMarketData();
                } catch (error) {
                    console.error('Error loading price data:', error);
                    showError(error.message, widgetId);
                    document.getElementById('btcPrice').textContent = 'Error';
                }
            }

            async loadMarketData() {
                const widgetId = 'market-data-widget';
                try {
                    const [globalResponse, btcResponse] = await Promise.all([
                        fetch(`${appConfig.coinGeckoApiUrl}/global`),
                        fetch(`${appConfig.coinGeckoApiUrl}/coins/bitcoin`)
                    ]);

                    if (!globalResponse.ok) throw new Error(`CoinGecko API error (${globalResponse.status}) for global data`);
                    const globalData = await globalResponse.json();

                    if (!btcResponse.ok) throw new Error(`CoinGecko API error (${btcResponse.status}) for Bitcoin coin data`);
                    const btcData = await btcResponse.json();

                    const dominance = globalData.data.market_cap_percentage.btc;
                    document.getElementById('dominance').textContent = `${dominance.toFixed(1)}%`;
                    document.getElementById('headerDominance').textContent = `${dominance.toFixed(1)}%`;

                    const circulating = btcData.market_data.circulating_supply;
                    document.getElementById('circulating').textContent = `${this.formatNumber(circulating)} BTC`;

                    const supplyPercentage = (circulating / 21000000) * 100;
                    document.getElementById('supplyProgress').style.width = `${supplyPercentage}%`;
                    document.getElementById('supplyPercentage').textContent = `${supplyPercentage.toFixed(2)}%`;

                    const high24h = btcData.market_data.high_24h[this.currency.toLowerCase()];
                    const low24h = btcData.market_data.low_24h[this.currency.toLowerCase()];
                    document.getElementById('high24h').textContent = this.formatCurrency(high24h, this.currency);
                    document.getElementById('low24h').textContent = this.formatCurrency(low24h, this.currency);

                    clearError(widgetId);
                    clearError('bitcoin-price-widget');
                } catch (error) {
                    console.error('Error loading market data:', error);
                    showError(error.message, widgetId);
                    showError(error.message, 'bitcoin-price-widget');
                }
            }

            async loadFearGreedIndex() {
                const widgetId = 'fear-greed-widget';
                try {
                    const response = await fetch(appConfig.fearGreedApiUrl);
                    if (!response.ok) throw new Error(`Alternative.me API error (${response.status})`);
                    const data = await response.json();

                    if (data.data && data.data[0]) {
                        const fearGreedData = data.data[0];
                        const value = parseInt(fearGreedData.value);
                        this.updateFearGreedGauge(value, fearGreedData.value_classification);

                        const timestamp = new Date(parseInt(fearGreedData.timestamp) * 1000);
                        document.getElementById('fearGreedUpdate').textContent = `Updated: ${timestamp.toLocaleDateString()}`;
                        document.getElementById('headerFearGreed').textContent = value;
                        clearError(widgetId);
                    } else {
                        throw new Error('No data received from Fear & Greed API.');
                    }
                } catch (error) {
                    console.error('Error loading fear & greed index:', error);
                    showError(error.message, widgetId);
                    this.updateFearGreedGauge(50, "Neutral (Error)");
                }
            }

            updateFearGreedGauge(value, labelText = null) {
                const canvas = document.getElementById('fearGreedGauge');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const centerX = canvas.width / 2;
                const centerY = canvas.height - 20;
                const radius = Math.min(centerX, centerY) - 20;
                const lineWidth = 20;

                // Background arc
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, Math.PI, 0);
                ctx.strokeStyle = 'rgba(120, 120, 120, 0.2)';
                ctx.lineWidth = lineWidth;
                ctx.lineCap = 'round';
                ctx.stroke();

                // Value arc
                let color;
                if (value <= 24) color = '#ef4444';
                else if (value <= 46) color = '#f59e0b';
                else if (value <= 54) color = '#eab308';
                else if (value <= 74) color = '#22c55e';
                else color = '#10b981';

                const angle = Math.PI * (value / 100);
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, Math.PI, Math.PI + angle);
                ctx.strokeStyle = color;
                ctx.lineWidth = lineWidth;
                ctx.lineCap = 'round';
                ctx.stroke();

                // Center indicator
                const indicatorAngle = Math.PI + angle;
                const indicatorX = centerX + Math.cos(indicatorAngle) * (radius - 10);
                const indicatorY = centerY + Math.sin(indicatorAngle) * (radius - 10);
                
                ctx.beginPath();
                ctx.arc(indicatorX, indicatorY, 8, 0, 2 * Math.PI);
                ctx.fillStyle = color;
                ctx.fill();

                document.getElementById('fearGreedValue').textContent = value;
                document.getElementById('fearGreedValue').style.color = color;

                let finalLabel = labelText;
                if (!finalLabel) {
                    if (value <= 24) finalLabel = 'Extreme Fear';
                    else if (value <= 46) finalLabel = 'Fear';
                    else if (value <= 54) finalLabel = 'Neutral';
                    else if (value <= 74) finalLabel = 'Greed';
                    else finalLabel = 'Extreme Greed';
                }

                document.getElementById('fearGreedLabel').textContent = finalLabel;
                document.getElementById('fearGreedLabel').style.color = color;
            }

            async loadNetworkStats() {
                const widgetId = 'network-stats-widget';
                try {
                    const [hashRateResponse, difficultyResponse, blockHeightResponse] = await Promise.all([
                        fetch(`${appConfig.mempoolSpaceApiUrl}/v1/mining/hashrate/1w`),
                        fetch(`${appConfig.mempoolSpaceApiUrl}/v1/difficulty-adjustment`),
                        fetch(`${appConfig.mempoolSpaceApiUrl}/blocks/tip/height`)
                    ]);

                    if (!hashRateResponse.ok) throw new Error(`Mempool API error (${hashRateResponse.status}) for hashrate`);
                    const hashRateData = await hashRateResponse.json();

                    if (!difficultyResponse.ok) throw new Error(`Mempool API error (${difficultyResponse.status}) for difficulty`);
                    const difficultyData = await difficultyResponse.json();

                    if (!blockHeightResponse.ok) throw new Error(`Mempool API error (${blockHeightResponse.status}) for block height`);
                    const blockHeight = await blockHeightResponse.text();

                    const currentHashRate = hashRateData.currentHashrate;
                    document.getElementById('hashRate').textContent = `${(currentHashRate / 1e18).toFixed(2)} EH/s`;

                    const currentDifficulty = difficultyData.currentDifficulty;
                    document.getElementById('difficulty').textContent = `${(currentDifficulty / 1e12).toFixed(2)} T`;

                    const difficultyChange = difficultyData.difficultyChange;
                    const changeDirection = difficultyChange >= 0 ? '+' : '';
                    const nextDiffEl = document.getElementById('nextDifficulty');
                    nextDiffEl.textContent = `${changeDirection}${difficultyChange.toFixed(2)}%`;
                    nextDiffEl.className = `metric-value ${difficultyChange >= 0 ? 'positive' : 'negative'}`;

                    const blockHeightNum = parseInt(blockHeight);
                    this.currentBlockHeight = blockHeightNum;
                    document.getElementById('blockHeight').textContent = blockHeightNum.toLocaleString();
                    document.getElementById('headerBlocks').textContent = blockHeightNum.toLocaleString();

                    clearError(widgetId);
                    await this.updateHalvingCountdown();

                } catch (error) {
                    console.error('Error loading network stats:', error);
                    showError(error.message, widgetId);
                }
            }

            async updateHalvingCountdown() {
                const widgetId = 'network-stats-widget';
                try {
                    let currentBlock = this.currentBlockHeight;
                    if (currentBlock === null || currentBlock === undefined) {
                        const blockHeightResponse = await fetch(`${appConfig.mempoolSpaceApiUrl}/blocks/tip/height`);
                        if (!blockHeightResponse.ok) throw new Error('Could not fetch block height for halving');
                        currentBlock = parseInt(await blockHeightResponse.text());
                        this.currentBlockHeight = currentBlock;
                    }
                    if (isNaN(currentBlock)) throw new Error("Invalid block height data for halving.");

                    const halvingBlockInterval = 210000;
                    const currentEpoch = Math.floor(currentBlock / halvingBlockInterval);
                    const nextHalvingBlockTarget = (currentEpoch + 1) * halvingBlockInterval;

                    if (currentBlock >= nextHalvingBlockTarget) {
                        document.getElementById('halvingCountdown').textContent = `Halving passed/imminent (Block ${nextHalvingBlockTarget.toLocaleString()})`;
                        return;
                    }

                    const blocksRemaining = nextHalvingBlockTarget - currentBlock;
                    const avgBlockTime = 10;
                    const minutesRemaining = blocksRemaining * avgBlockTime;
                    const daysRemaining = Math.floor(minutesRemaining / (60 * 24));
                    const hoursRemaining = Math.floor((minutesRemaining % (60 * 24)) / 60);

                    document.getElementById('halvingCountdown').textContent = `~${daysRemaining}d ${hoursRemaining}h (${blocksRemaining.toLocaleString()} blocks)`;
                } catch (error) {
                    console.error('Error updating halving countdown:', error);
                    showError(`Halving countdown: ${error.message}`, widgetId);
                    document.getElementById('halvingCountdown').textContent = `~ N/A`;
                }
            }

            async loadMempoolData() {
                const widgetId = 'mempool-data-widget';
                try {
                    const [feeResponse, mempoolResponse] = await Promise.all([
                        fetch(`${appConfig.mempoolSpaceApiUrl}/v1/fees/recommended`),
                        fetch(`${appConfig.mempoolSpaceApiUrl}/mempool`)
                    ]);

                    if (!feeResponse.ok) throw new Error(`Mempool API error (${feeResponse.status}) for fees`);
                    const feeData = await feeResponse.json();

                    if (!mempoolResponse.ok) throw new Error(`Mempool API error (${mempoolResponse.status}) for mempool size`);
                    const mempoolData = await mempoolResponse.json();

                    document.getElementById('highPriorityFee').textContent = `${feeData.fastestFee} sat/vB`;
                    document.getElementById('mediumPriorityFee').textContent = `${feeData.halfHourFee} sat/vB`;
                    document.getElementById('lowPriorityFee').textContent = `${feeData.hourFee} sat/vB`;
                    document.getElementById('mempoolSize').textContent = `${(mempoolData.vsize / 1e6).toFixed(2)} vMB`;
                    clearError(widgetId);
                } catch (error) {
                    console.error('Error loading mempool data:', error);
                    showError(error.message, widgetId);
                }
            }

            async loadRecentBlocks() {
                const widgetId = 'recent-blocks-widget';
                try {
                    const response = await fetch(`${appConfig.mempoolSpaceApiUrl}/v1/blocks`);
                    if (!response.ok) throw new Error(`Mempool API error (${response.status}) for recent blocks`);
                    const blocks = await response.json();

                    const recentBlocksHtml = blocks.slice(0, 5).map(block => `
                    <div class="metric-row">
                        <span class="metric-label">#${block.height.toLocaleString()}</span>
                        <span class="metric-value">${block.tx_count} txs • ${(block.size / 1e6).toFixed(2)} MB</span>
                    </div>`).join('');
                    document.getElementById('recentBlocks').innerHTML = recentBlocksHtml;
                    clearError(widgetId);
                } catch (error) {
                    console.error('Error loading recent blocks:', error);
                    showError(error.message, widgetId);
                    document.getElementById('recentBlocks').innerHTML = `<p class="loading-text" style="color:var(--negative-change)">Failed to load blocks.</p>`;
                }
            }

            async loadPriceChart() {
                const widgetId = 'price-chart-widget';
                clearError(widgetId);
                const canvas = document.getElementById('priceChart');
                const ctx = canvas.getContext('2d');

                if (this.priceChart) {
                    this.priceChart.destroy();
                    this.priceChart = null;
                }

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.save();
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#9ca3af';
                ctx.font = '16px var(--font-family)';
                ctx.fillText('Loading chart data...', canvas.width / 2, canvas.height / 2);
                ctx.restore();

                try {
                    const days = this.currentTimeframe === 'max' ? 'max' : this.currentTimeframe;
                    const interval = (days === '1' || parseInt(days) <= 2) ? 'hourly' : 'daily';

                    const response = await fetch(`${appConfig.coinGeckoApiUrl}/coins/bitcoin/market_chart?vs_currency=${this.currency.toLowerCase()}&days=${days}&interval=${interval}`);

                    if (!response.ok) {
                        let errorMsg = `CoinGecko API error (${response.status})`;
                        try {
                            const errorData = await response.json();
                            errorMsg = `Chart data error: ${errorData.error || response.statusText || 'Unknown API issue'}`;
                        } catch (e) { /* Failed to parse error JSON */ }
                        throw new Error(errorMsg);
                    }
                    const data = await response.json();

                    if (!data.prices || data.prices.length === 0) {
                        throw new Error('No price data returned from API.');
                    }

                    this.renderPriceChart(data.prices);
                    clearError(widgetId);
                } catch (error) {
                    console.error('Error loading price chart:', error);
                    showError(`Chart: ${error.message}`, widgetId);

                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.save();
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#ef4444';
                    ctx.font = '14px var(--font-family)';
                    const maxErrorWidth = canvas.width * 0.9;
                    let displayError = error.message;
                    if (ctx.measureText(displayError).width > maxErrorWidth) {
                        while (ctx.measureText(displayError + '...').width > maxErrorWidth && displayError.length > 10) {
                            displayError = displayError.slice(0, -1);
                        }
                        displayError += '...';
                    }
                    ctx.fillText(displayError, canvas.width / 2, canvas.height / 2);
                    ctx.restore();
                }
            }

            renderPriceChart(priceData) {
                const ctx = document.getElementById('priceChart').getContext('2d');

                if (this.priceChart) {
                    this.priceChart.destroy();
                }

                const gridColor = 'rgba(255, 255, 255, 0.05)';
                const tickColor = '#9ca3af';
                const legendLabelColor = '#e8e9ea';
                const tooltipBgColor = 'rgba(30, 30, 30, 0.95)';
                const tooltipFontColor = '#f0f0f0';
                const chartBorderColor = '#f7931a';
                const chartBackgroundColor = 'rgba(247, 147, 26, 0.1)';

                const labels = priceData.map(point => {
                    const date = new Date(point[0]);
                    if (this.currentTimeframe === '1' || parseInt(this.currentTimeframe) <= 2) {
                        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    }
                    return date.toLocaleDateString([], { month: 'short', day: 'numeric' });
                });

                const prices = priceData.map(point => point[1]);

                this.priceChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: `Bitcoin Price (${this.currency.toUpperCase()})`,
                            data: prices,
                            borderColor: chartBorderColor,
                            backgroundColor: chartBackgroundColor,
                            borderWidth: 2,
                            fill: true,
                            tension: 0.3,
                            pointRadius: (this.currentTimeframe === '1' || parseInt(this.currentTimeframe) <= 7) ? 1.5 : 0,
                            pointHoverRadius: 6,
                            pointBackgroundColor: chartBorderColor,
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: {
                            duration: 500,
                            easing: 'easeInOutQuart'
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top',
                                labels: {
                                    color: legendLabelColor,
                                    font: {
                                        size: 13,
                                        family: 'var(--font-family)',
                                        weight: '500'
                                    }
                                }
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                backgroundColor: tooltipBgColor,
                                titleColor: tooltipFontColor,
                                bodyColor: tooltipFontColor,
                                borderColor: chartBorderColor,
                                borderWidth: 1,
                                titleFont: { family: 'var(--font-family)', weight: 'bold' },
                                bodyFont: { family: 'var(--font-family)' },
                                padding: 12,
                                cornerRadius: 8,
                                callbacks: {
                                    label: function (context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed.y !== null) {
                                            label += this.formatCurrency(context.parsed.y, this.currency, {
                                                minimumFractionDigits: 2,
                                                maximumFractionDigits: (this.currency.toLowerCase() === 'btc' ? 8 : 2)
                                            });
                                        }
                                        return label;
                                    }.bind(this)
                                }
                            }
                        },
                        scales: {
                            x: {
                                grid: {
                                    color: gridColor,
                                    drawBorder: false,
                                },
                                ticks: {
                                    color: tickColor,
                                    maxTicksLimit: (this.currentTimeframe === '1' || parseInt(this.currentTimeframe) <= 2) ? 10 : 7,
                                    font: {
                                        size: 11,
                                        family: 'var(--font-family)'
                                    }
                                }
                            },
                            y: {
                                grid: {
                                    color: gridColor,
                                    drawBorder: false,
                                },
                                ticks: {
                                    color: tickColor,
                                    font: {
                                        size: 11,
                                        family: 'var(--font-family)'
                                    },
                                    callback: function (value) {
                                        return this.formatCurrency(value, this.currency);
                                    }.bind(this)
                                }
                            }
                        }
                    }
                });
            }

            setupPeriodicUpdates() {
                setInterval(() => {
                    this.loadPriceData();
                    this.loadMempoolData();
                }, 60000);

                setInterval(() => {
                    this.loadNetworkStats();
                    this.loadRecentBlocks();
                }, 120000);

                setInterval(() => {
                    this.loadFearGreedIndex();
                }, 300000);
            }

            formatCurrency(value, currencyCode, options = {}) {
                const defaultOptions = { style: 'currency', currency: currencyCode.toUpperCase() };
                const effectiveOptions = { ...defaultOptions, ...options };

                if (currencyCode.toLowerCase() === 'usd' || currencyCode.toLowerCase() === 'eur' || currencyCode.toLowerCase() === 'gbp') {
                    if (value < 1 && value > -1 && value !== 0) {
                        effectiveOptions.minimumFractionDigits = 2;
                        effectiveOptions.maximumFractionDigits = 2;
                    } else {
                        effectiveOptions.minimumFractionDigits = (value % 1 === 0 && !options.minimumFractionDigits) ? 0 : 2;
                        effectiveOptions.maximumFractionDigits = 2;
                    }
                } else {
                    effectiveOptions.minimumFractionDigits = (value % 1 === 0 && !options.minimumFractionDigits) ? 0 : 2;
                    effectiveOptions.maximumFractionDigits = (currencyCode.toLowerCase() === 'btc' ? 8 : 2);
                }
                if (value === null || value === undefined) return 'N/A';

                return new Intl.NumberFormat('en-US', effectiveOptions).format(value);
            }

            formatLargeNumber(value, currency) {
                if (value === null || value === undefined) return 'N/A';
                if (value >= 1e12) {
                    return this.formatCurrency(value / 1e12, currency, { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + 'T';
                } else if (value >= 1e9) {
                    return this.formatCurrency(value / 1e9, currency, { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + 'B';
                } else if (value >= 1e6) {
                    return this.formatCurrency(value / 1e6, currency, { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + 'M';
                }
                return this.formatCurrency(value, currency);
            }

            formatNumber(value) {
                if (value === null || value === undefined) return 'N/A';
                return new Intl.NumberFormat('en-US', {
                    minimumFractionDigits: 0,
                    maximumFractionDigits: 0
                }).format(value);
            }
        }

        // --- CURRENCY CONVERTER ---
        const CONVERTER_CURRENCIES = ["USD", "EUR", "ZAR", "JPY", "GBP", "BTC"];
        const fromEl = document.getElementById('fromCurrency');
        const toEl = document.getElementById('toCurrency');
        const amountEl = document.getElementById('amount');
        const resultEl = document.getElementById('result');

        CONVERTER_CURRENCIES.forEach(c => {
            fromEl.add(new Option(c, c)); toEl.add(new Option(c, c));
        });
        fromEl.value = "USD"; toEl.value = "BTC";

        async function convert() {
            const amount = parseFloat(amountEl.value);
            const fromC = fromEl.value;
            const toC = toEl.value;
            resultEl.textContent = 'Converting...';

            if (isNaN(amount) || amount < 0) { resultEl.textContent = 'Please enter a valid amount.'; return; }
            if (fromC === toC) {
                const precision = (fromC === 'BTC') ? 8 : 2;
                resultEl.textContent = `${amount.toFixed(precision)} ${fromC}`; return;
            }

            try {
                let convertedAmount;
                if (fromC === 'BTC' && toC !== 'BTC') {
                    const res = await fetch(`${appConfig.coinGeckoApiUrl}/simple/price?ids=bitcoin&vs_currencies=${toC.toLowerCase()}`);
                    if (!res.ok) throw new Error(`CoinGecko API error (${res.status})`);
                    const data = await res.json();
                    if (!data.bitcoin || !data.bitcoin[toC.toLowerCase()]) throw new Error(`Rate BTC to ${toC} unavailable`);
                    convertedAmount = amount * data.bitcoin[toC.toLowerCase()];
                } else if (fromC !== 'BTC' && toC === 'BTC') {
                    const res = await fetch(`${appConfig.coinGeckoApiUrl}/simple/price?ids=bitcoin&vs_currencies=${fromC.toLowerCase()}`);
                    if (!res.ok) throw new Error(`CoinGecko API error (${res.status})`);
                    const data = await res.json();
                    if (!data.bitcoin || !data.bitcoin[fromC.toLowerCase()]) throw new Error(`Rate ${fromC} to BTC unavailable`);
                    convertedAmount = amount / data.bitcoin[fromC.toLowerCase()];
                } else {
                    const res = await fetch(`https://api.frankfurter.app/latest?amount=${amount}&from=${fromC}&to=${toC}`);
                    if (!res.ok) throw new Error(`Frankfurter API error (${res.status})`);
                    const data = await res.json();
                    if (!data.rates || data.rates[toC] === undefined) throw new Error(`Rate ${fromC} to ${toC} unavailable`);
                    convertedAmount = data.rates[toC];
                }
                const outputPrecision = (toC === 'BTC') ? 8 : 2;
                const inputDisplayAmount = (fromC === 'BTC') ? amount.toFixed(8) : amount.toFixed(2);
                resultEl.textContent = `${inputDisplayAmount} ${fromC} = ${convertedAmount.toFixed(outputPrecision)} ${toC}`;
            } catch (err) {
                resultEl.textContent = `Error: ${err.message}`; console.error("Conversion Error:", err);
            }
        }

        // --- ADDITIONAL WIDGETS AND FEATURES ---
        const newsContainer = document.getElementById('news-container');
        const newsLoadingElement = document.getElementById('loading');
        const categoryButtons = document.querySelectorAll('.category-btn');
        const copyrightYearEl = document.getElementById('copyright-year');
        const quoteButton = document.getElementById('quote-button');
        const marketOverviewContent = document.getElementById('market-overview-content');
        const termTitleEl = document.getElementById('term-title');
        const termDefinitionEl = document.getElementById('term-definition');
        const newTermButton = document.getElementById('new-term-button');
        const mainCurrencySelect = document.getElementById('currencySelect');

        function loadPreferences() {
            const savedCurrency = localStorage.getItem(appConfig.storageKeys.selectedCurrency) || appConfig.defaultCurrency;
            if (mainCurrencySelect) {
                mainCurrencySelect.value = savedCurrency;
            }
        }

        function globalFormatCurrency(amount, currencyCode, options = {}) {
            const defaultOptions = { style: 'currency', currency: currencyCode.toUpperCase(), minimumFractionDigits: 2, maximumFractionDigits: 2 };
            try {
                return new Intl.NumberFormat(undefined, { ...defaultOptions, ...options }).format(amount);
            } catch (e) {
                console.warn(`Formatting failed for ${currencyCode}, using fallback. Error: ${e.message}`);
                const symbolMap = { 'usd': '$', 'eur': '€', 'gbp': '£', 'jpy': '¥', 'zar': 'R' };
                const prefix = symbolMap[currencyCode.toLowerCase()] || currencyCode.toUpperCase() + ' ';
                return `${prefix}${amount.toFixed(options.maximumFractionDigits !== undefined ? options.maximumFractionDigits : 2)}`;
            }
        }

        // MARKET OVERVIEW (Other Coins)
        async function fetchMarketOverviewData(currency) {
            const widgetId = 'market-overview-widget';
            clearError(widgetId);
            marketOverviewContent.innerHTML = '<p class="loading-text">Loading market data...</p>';
            const coinIds = 'ethereum,solana,binancecoin,cardano,ripple';
            const coinDetails = {
                'ethereum': { name: 'Ethereum', symbol: 'ETH', logo: 'https://assets.coingecko.com/coins/images/279/small/ethereum.png' },
                'solana': { name: 'Solana', symbol: 'SOL', logo: 'https://assets.coingecko.com/coins/images/4128/small/solana.png' },
                'binancecoin': { name: 'BNB', symbol: 'BNB', logo: 'https://assets.coingecko.com/coins/images/825/small/bnb-icon2_2x.png' },
                'cardano': { name: 'Cardano', symbol: 'ADA', logo: 'https://assets.coingecko.com/coins/images/975/small/cardano.png' },
                'ripple': { name: 'XRP', symbol: 'XRP', logo: 'https://assets.coingecko.com/coins/images/44/small/xrp-symbol-white-128.png' }
            };

            try {
                const response = await fetch(`${appConfig.coinGeckoApiUrl}/simple/price?ids=${coinIds}&vs_currencies=${currency.toLowerCase()}&include_24hr_change=true`);
                if (!response.ok) throw new Error(`CoinGecko API Error: ${response.statusText} (Status ${response.status})`);
                const data = await response.json();

                let html = '';
                for (const id in data) {
                    if (data[id] && coinDetails[id]) {
                        const price = data[id][currency.toLowerCase()];
                        const change = data[id][`${currency.toLowerCase()}_24h_change`];
                        html += `
                        <div class="metric-row">
                            <span class="metric-label">
                                <img src="${coinDetails[id].logo}" alt="${coinDetails[id].name} logo" class="coin-logo" loading="lazy">
                                ${coinDetails[id].name} (${coinDetails[id].symbol})
                            </span>
                            <span class="metric-value">
                                ${bitnexysApp ? bitnexysApp.formatCurrency(price, currency) : globalFormatCurrency(price, currency)}
                                <small class="${change >= 0 ? 'positive' : 'negative'}">(${change ? change.toFixed(2) : 'N/A'}%)</small>
                            </span>
                        </div>`;
                    }
                }
                marketOverviewContent.innerHTML = html || '<p>No data available for other coins.</p>';
                clearError(widgetId);
            } catch (error) {
                showError(error.message || 'Failed to load market overview.', widgetId);
                marketOverviewContent.innerHTML = '<p class="loading-text" style="color: var(--negative-change);">Error loading data.</p>';
            }
        }

        // CRYPTO TERM
        function displayCryptoTerm() {
            const randomIndex = Math.floor(Math.random() * appConfig.cryptoTerms.length);
            const term = appConfig.cryptoTerms[randomIndex];
            if (termTitleEl && termDefinitionEl) {
                termTitleEl.textContent = term.term;
                termDefinitionEl.textContent = term.definition;
            }
        }

        // NEWS FEED (Reddit)
        async function fetchNews(category = 'all_crypto') {
            const widgetId = 'news-feed-widget';
            clearError(widgetId);
            newsLoadingElement.style.display = 'block';
            newsContainer.innerHTML = '';

            if (cachedNews[category] && (Date.now() - cachedNews[category].timestamp < 300000)) {
                displayNews(cachedNews[category].data);
                newsLoadingElement.style.display = 'none';
                return;
            }

            try {
                const redditUrl = redditSources[category];
                if (!redditUrl) throw new Error(`Invalid news category: ${category}`);

                const response = await fetch(redditUrl);
                if (!response.ok) {
                    let errorMsg = `Failed to fetch news (status: ${response.status} ${response.statusText})`;
                    try { const errorData = await response.json(); errorMsg = `Reddit API Error: ${errorData.message || response.statusText} (status: ${response.status})`; } catch (e) { /*ignore*/ }
                    throw new Error(errorMsg);
                }
                const data = await response.json();
                const posts = data?.data?.children
                    .filter(post => !post?.data?.stickied && !post?.data?.over_18 && post?.data?.title && post?.data?.permalink)
                    .slice(0, 10) || [];

                cachedNews[category] = { data: posts, timestamp: Date.now() };
                displayNews(posts);
                clearError(widgetId);
            } catch (error) {
                showError(error.message || 'Failed to load news. Try again later.', widgetId, true);
                newsContainer.innerHTML = '';
            } finally {
                newsLoadingElement.style.display = 'none';
            }
        }

        function escapeHTML(str) {
            if (typeof str !== 'string') return '';
            return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
        }

        function displayNews(posts) {
            newsContainer.innerHTML = '';
            if (!posts || posts.length === 0) {
                newsContainer.innerHTML = '<p style="text-align: center; opacity: 0.8; padding: 30px;">No news found in this category, or Reddit is rate-limiting. Try again later!</p>';
                return;
            }
            posts.forEach(post => {
                const item = post.data;
                const card = document.createElement('div');
                card.className = 'news-item';
                const createdDate = new Date(item.created_utc * 1000);
                const formattedDate = createdDate.toLocaleString(undefined, { dateStyle: 'medium', timeStyle: 'short' });

                const title = escapeHTML(item.title);
                let selftext = item.selftext ? escapeHTML(item.selftext) : '';
                if (selftext.length > 150) selftext = selftext.substring(0, 150) + '...';

                let imageUrl = '';
                if (item.preview?.images?.[0]?.source?.url) {
                    imageUrl = item.preview.images[0].source.url.replace(/&amp;/g, '&');
                } else if (item.thumbnail && item.thumbnail.startsWith('http')) {
                    imageUrl = item.thumbnail.replace(/&amp;/g, '&');
                }

                card.innerHTML = `
                ${imageUrl ? `<img src="${imageUrl}" alt="Preview for ${title.substring(0, 30)}..." loading="lazy">` : ''}
                <h3><a href="https://reddit.com${item.permalink}" target="_blank" rel="noopener noreferrer">${title}</a></h3>
                <p class="meta-info">
                    <span>r/${escapeHTML(item.subreddit)}</span>
                    <span>•</span>
                    <span>${formattedDate}</span>
                    <span>•</span>
                    <span>👍 ${item.ups?.toLocaleString() || 0}</span>
                    <span>•</span>
                    <span>💬 ${item.num_comments?.toLocaleString() || 0}</span>
                </p>
                ${selftext ? `<p style="margin-top: 10px;">${selftext}</p>` : ''}
                <a href="https://reddit.com${item.permalink}" target="_blank" rel="noopener noreferrer" style="font-size: 0.9em; display: inline-block; margin-top: 15px; color: var(--accent-color); font-weight: 500;">Read on Reddit →</a>
            `;
                newsContainer.appendChild(card);
            });
        }

        function changeNewsCategory(category) {
            if (currentNewsCategory === category) return;
            currentNewsCategory = category;
            categoryButtons.forEach(button => {
                button.classList.toggle('active', button.dataset.source === category);
            });
            fetchNews(category);
        }

        // CRYPTO QUOTE
        function getCryptoQuote() {
            const quoteElement = document.getElementById('quote-text');
            const quotes = appConfig.cryptoQuotes;

            if (quoteElement && quoteButton) {
                const originalButtonText = quoteButton.innerHTML;
                quoteElement.style.opacity = '0.5';
                quoteElement.textContent = 'Thinking... 🤔';
                quoteButton.disabled = true;
                quoteButton.innerHTML = '💬 Fetching...';

                setTimeout(() => {
                    const randomIndex = Math.floor(Math.random() * quotes.length);
                    quoteElement.textContent = `"${quotes[randomIndex]}"`;
                    quoteElement.style.opacity = '1';
                    quoteButton.disabled = false;
                    quoteButton.innerHTML = originalButtonText;
                }, 500);
            }
        }

        function setCopyrightYear() {
            const currentYear = new Date().getFullYear();
            if (copyrightYearEl) {
                copyrightYearEl.innerHTML = `© ${currentYear} BitNexys by <a href="https://vylexnexys.co.za/">VylexNexys</a>. All rights reserved.`;
            }
        }

        // --- INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', () => {
            loadPreferences();

            const savedCurrency = (mainCurrencySelect && mainCurrencySelect.value) || localStorage.getItem(appConfig.storageKeys.selectedCurrency) || appConfig.defaultCurrency;
            bitnexysApp = new BitNexys(savedCurrency);

            fetchMarketOverviewData(savedCurrency);
            fetchNews(currentNewsCategory);
            displayCryptoTerm();
            getCryptoQuote();
            setCopyrightYear();

            categoryButtons.forEach(button => {
                button.addEventListener('click', () => {
                    changeNewsCategory(button.dataset.source);
                });
            });

            if (newTermButton) {
                newTermButton.addEventListener('click', displayCryptoTerm);
            }

            if (quoteButton) {
                quoteButton.addEventListener('click', getCryptoQuote);
            }
        });

    </script>
</body>

</html>
